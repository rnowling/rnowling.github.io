---
layout: post
title:  "Introducing CheckStructure and Some Initial Impressions of Clojure"
date:   2019-03-30 12:13:19
categories: "programming"
tags: ["clojure", "static analysis"]
---

My colleagues and I have been in search of ways to automate some aspects of grading student assignments for the first-year programming courses at MSOE.  Our goal is not to automate all of the grading but introduce automated checks that will catch errors on submission. We intend to use this to give students immediate feedback (and chances to resubmit), while also reducing the amount of effort instructors spend on "basic" checks.  In many of our first-year assignments, we specify the structure of the program for students including specifications for the packages, classes, and methods.  Inspired by [checkstyle](https://github.com/checkstyle/checkstyle), which we already use with great success, I've started to prototype a tool I'm calling "CheckStructure" that is designed to check a student's submission against our specification.

I'm envisioning that CheckStructure will initially have three modes of operation:

1. Generating a specification from example code
2. Validating that a specification (encoded as a JSON document) follows the schema
3. Checking some input code against a specification

I can see CheckStructure expanding far beyond the original use case.  It would be nice to add checks for anti-patterns in logic (e.g., checking if a boolean variable is true) and offer suggestions for improvements.

Eventually, I can see CheckStructure being used as a static analysis tool at the intersection of research in programming languages and education.  For example, several researchers have used [static analysis tools](https://dl.acm.org/citation.cfm?id=2960326) to study the space of solutions generated by students.

## Choosing a Language
Tasks 1 and 3 will require parsing Java source code.  Thankfully, there is an existing library for parsing Java source code called [JavaParser](https://javaparser.org/).  Using JavaParser will save significant amounts of time compared with implementing our own parser.   The library does limit us to JVM-based languages, however.

Generally speaking, parsing and analyzing heterogenous trees in statically-typed object-oriented languages is painful, even with the [visitor pattern](https://en.wikipedia.org/wiki/Visitor_pattern).  This immediately ruled out Java and Kotlin in my eyes.

Representing the trees themselves and the analysis algorithms are often much easier in functional or dynamically-typed languages.  For statically-typed languages, [algebraic data types (ADTs)](https://en.wikipedia.org/wiki/Algebraic_data_type) and [pattern matching](https://en.wikipedia.org/wiki/Pattern_matching) are a very natural way to represent and analyze trees.   Although Scala technically supports ADTs, I find Scala to be heavyweight compared with OCaml or Rust.  In dynamically-typed languages, trees can be represented as plain data structures such as lists and maps.

That effectively left Clojure, Jython, JRuby, and Groovy.  In the end, I decided to go with Clojure.  Jython hasn't been updated in a while and appears to be a dead project.  Most of the heavy lifting in Checkstructure will involve traversing and operating on trees represented as recursive embeddings of lists, maps, and sets. Clojure provides a large library of built-in functions just for that purpose.

## Some Initial Lessons Learned
I've begun to prototype Checkstructure by focusing on the logic to validate specifications.  Already in doing so, I've learned a few lessons:

1. **Lein makes everything easy:** I'm not entirely new to Clojure, but I was reminded of how easy it is to get started on a Clojure project with [leiningen](https://leiningen.org/).  Lein also makes it easy to pull down dependencies, run tests, open a REPL, and build a jar.

2. **Use plain data structures:**  I originally tried writing validation code directly against GSON's [JsonElement](https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/JsonElement.html) API.  I quickly found this to be cumbersome and challenging.  I found that it was significantly more productive to first deserialize the JSON document into Clojure data structures using the [Cheshire](https://github.com/dakrone/cheshire) library and then write the validation code against the result.

3. **Keep functions small and write lots of tests:** As a dynamic language, I often found myself unsure of what many Clojure functions expected as input or what the resulting output would be like.  Since many of Clojure's functions are powerful, you end up performing large transformations with even small bits of code.  And on top of that, Clojure's stacktraces are not terribly informative.  I found that the best way to be productive was to keep functions small and write corresponding tests as I went along.  I ended up making all of my functions public so that [clojure.test](https://clojure.github.io/clojure/clojure.test-api.html) could access them -- this is probably an anti-pattern.

## Going Forward
Checkstructure is probably best described as no more than a "sparkle in its father's eye" at this point.  As the project progresses, I'm excited to have an opportunity to both learn more about Clojure and see how it holds up.  Most of the Clojure projects I've come across are small projects with short lifespans.  Many of the pain points of a language or ecosystem do not become apparent until you have at least tens of thousands lines of code, multiple developers, and are trying to add new features / fix bugs on top of an existing architecture without introducing regressions.

In mean time, I'm already identifying resources that could help me improve Checkstructure. For example, the maybe, either, and try monads from the [cats](http://funcool.github.io/cats/latest/#introduction) library would make it easier to propagating errors and messages while also reducing the amount of boilerplate I have to write.
